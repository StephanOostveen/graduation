\section{Conclusion}
\label{sec:conclusion}
This research started because Lightyear wanted to investigate how Time Sensitive Networking (TSN) could be applied in a solar vehicle, following the trend in automotive architectures. As we have seen in section~\ref{sec:real-time-comm} and appendix~\ref{appendix:tsn} TSN is not a single standard like CAN, but a set of standards which can be combined and configured in different ways resulting in vastly different performance. Combined with the fact that all prior knowledge of the CAN based architectures cannot be used it is unlikely that choosing a network configuration without some form of analysis will lead to success. To reduce complexity further it was assumed that existing applications would be reused, and only the network interface software would be changed. Hence the research focussed on finding a method for evaluating the effect of various network architectures assuming code reuse. Three methods for performance exist, performing measurements on a system, mathematical analysis and simulation. The problem with measurements is that one first needs to build the system, which is impractical for Lightyear. As we have seen in section~\ref{subsec:analysis} analysis methods exist for TSN and CAN, the advantages are that it gives clear and exact insights in the relationship between variables and performance. Drawbacks are that reality must often be simplified to make it feasible and specifically in the case of TSN the methods are still under development. Simulation is not an exact method, but the system can be modelled more accurately. Simulation also allows inspecting the inner working of the subsystems without interfering with the results as is the case with measurements. Given the availability of CAN and TSN models for the \omnet simulation framework it was chosen as a basis for the evaluation method. In section~\ref{subsec:benchmark} we looked at several available benchmarks but concluded that they did not fairly represent the Lightyear 0's in-vehicle network. Which is necessary for the simulation to be able to evaluate the effects of the network on Lightyear's software.

In section~\ref{subsec:network} we describe the in-vehicle networks of the Lightyear 0. We saw that 10 CAN busses are used to connect more than 50 nodes in a partially connected topology. Three main nodes, the Safety Controller, Vehicle Controller and Central Gateway, serve as the backbone of the network acting as the bridges between the various networks. Two LIN networks and 5 Ethernet networks where also identified. Indicating the need for higher speed networks in a solar electric vehicle. We further described the execution model of the three main nodes such that further analysis can be performed. The nodes use a classical fixed priority scheduler with rate monotonic priority assignment. A simple but effective choice as long as the requirements are met. We did not perform an analysis of the execution times, so no conclusions can be drawn on the schedulability of the tasks. Interestingly only five different periods are used for tasks with the majority running at 10 or 50ms intervals.

Lightyear's software consistently used a specific interface of the OpenECU rtos to read and write the data dictionaries from their applications. This made it possible to search in the whole software's callgraph for function calls to these methods. The callgraph could easily be generated using the \textit{lld} linker of the llvm toolchain. Giving us the exact amount and location of reads and writes that occur in the final application. Analysing this result we found 162 data dictionaries that were never read or written. While according to the documentation they should have been, augmenting the precision of the benchmark. Other interesting results can be found in the benchmark, for example over- and under-sampling of data dictionaries, which could be used by the application designers and architects to refine the application software.

Similarly, we found that the reception and transmission of CAN messages also used a specific interface provided by the OpenECU rtos. The same callgraph analysis could be used to find which CAN messages are read and transmitted by each runnable. Information that otherwise was unknown. Unfortunately the callgraph analysis of the CAN message interface did not provide all necessary data to create a benchmark. Namely, message size, period, source/destination and CAN bus where missing. The CAN id and bus was manually recovered by analysing the call site code after which message size, period and source/destination information could be retrieved from the available DBC files. If the CAN information should be updated more often we suggest using a more structured approach of defining the CAN message reception/transmission, similar to the definition of the data dictionaries. As there is no inherent difference between the two communication methods. From inspecting the source code we have found instances where the callgraph analysis overestimates the number of reads and writes. This is inherent to the callgraph, as it lacks the context in which a function call is made. From validating various results we determine that the overestimation is limited and likely confined to the CAN message reception/transmission of a handful of runnables. A system architect could easily spot this and fix the model manually.

In section~\ref{sec:experiments} some experiments where performed to demonstrate that the extracted model is detailed enough to find bottlenecks and evaluate network performance of the CAN based network. As data dictionaries can be used by several runnables executing on different physical nodes it cannot be assumed that at any point in time the copies of the data dictionary are synchronized. Our experiments regarding the data dictionary age demonstrate that the model is detailed enough to evaluate the effects of a network configuration on the performance of the applications. Because the runnables communicate with each other in terms of data dictionaries the lower level communication layers can be interchanged transparently. Meaning the physical transport of data between the programmable end nodes can be changed from CAN to TSN without requiring to change the runnables or rtos in the simulation. This matches the automotive industry's strategy for the transition to a zonal architecture. They propose to first change the backbone of the network from CAN to TSN and let the zonal ECU's act as gateways for the legacy networks.

Some extra work is needed before the model can be used to accurately answer performance questions, mostly regarding accurate parameter selection for execution times, bit error rate, bit stuffing, the schedulers ordering in case of equal priority tasks.

\todo{conclusies voor further work en op het grotere plaatje.}