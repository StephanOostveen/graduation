\label{subsec:moddeling}
In this section we will describe how the Lightyear 0's embedded system as defined in Section~\ref{subsec:network} is modelled in OMNeT++. We also mention the assumptions made and the differences between the model and the real embedded system. The FiCo4OMNeT CAN models where used to avoid implementing all the necessary details of a CAN bus and devices. Changes where made to FiCo4OMNeT such that it works with \omnet 6.0.2, these changes are mostly implementation details, but also contain some bug fixes such as an incorrect message size for normal identifiers when extended identifiers are allowed in the network.

\paragraph{Programmable end nodes} OMNeT++ differentiates between simple modules and compound modules. Simple modules can be seen as the lowest level of the model, they implement the behaviour by means of C++ code which acts on the events received by that module. Compound modules do not have an implementation but serve as an abstraction layer grouping submodules and the connections between those submodules inside a named abstraction.

The programmable end nodes are implemented as a compound module. A generic compound module \textit{LyPhysicalNode} aggregates the internals of a programmable end node. Specializations of the \textit{LyPhysicalNode} implement the final specific programmable end node, e.g. the \textit{VCUNode} compound module represents the Vehicle Control Unit by filling in details like the number of data dictionaries and their names, the number of runnables with the names and priorities and the read/write relationship between runnables and data dictionaries of the real world Vehicle Control Unit. The specializations are generated from the source code such that they closely resemble the real world implementation. 

A \textit{LyPhysicalNode} consists of at least the following modules: the scheduler, one CAN source application, one CAN sink application, one up to four CAN devices. These modules represent the OpenECU RTOS as specified in section~\ref{subsec:programmablenode}. Their behaviour is modelled according to the documentation and the assumptions mentioned in section~\ref{subsec:programmablenode}. A graphical representation of the compound module as presented by \omnet can be found in Figure~\ref{fig:lyphysicalnode}

\begin{figure}[htb]
    \centering
    \includegraphics[width=0.5\textwidth]{images/LyPhysicalNode_example.png}
    \caption{Example LyPhysicalNode compound module}
    \label{fig:lyphysicalnode}
\end{figure}

For simplicity, we have only modelled the two CAN messaging tasks, the application background task from Table~\ref{tab:priorities} and the runnables implemented by Lightyear. The documentation did not specify the scheduler's behaviour when two or more tasks of the same priority level are eligible for execution, we chose to take a random task from the list of the highest priority ready and paused tasks. In reality there could be some implicit ordering as the tasks are listed in some datastructure such as an array or list through which the scheduler iterates. 

The CAN device is a module imported from the FiCo4OMNeT model~\cite{meyer2019simulation}. It takes care of CAN message arbitration by implementing a priority based schedule. The device has an infinite amount of transmit buffers, which is not realistic. The source application module limits the number of messages buffered for transmission by the CAN device to a constant called \textit{hardwareBufferSize} which can be modified in the experiment setup. If more than two CAN messages are scheduled for transmission by the runnables the CAN source task will store them in a software buffer following the priority queue mechanism. If a frame with a specific ID is retransmitted by a runnable before it was moved from the software buffer to the hardware buffer it will be overwritten as is defined in the documentation. All messages transmitted by runnables pass through the single CAN source application such that there is a single module responsible for maintaining the CAN bus invariants as defined in the OpenECU documentation. \todo{explain effects of this no realism on the validaity of a simulation.}

The CAN device implemented by FiCo4OMNeT has no receive buffers and will immediately transfer a received message to the sink application. This is not realistic behaviour, often a CAN peripheral will have one or more hardware receive buffers. And emits an interrupt, signalling that a CAN frame is available. For this reason the reception of a CAN message does not require any scheduling of the CAN sink application in our model. Once one or more messages are buffered, the sink app will change its state from Blocked to Ready, signalling to the scheduler that it needs to be executed. Upon execution the sink application will move the received frames to its software buffer. Internally the sink application keeps track of the last received instance of each registered CAN message in a software buffer, consistent with the OpenECU documentation. Runnables can request the last received instance of a CAN message from the sink application. Such a request does not cause the sink application to be scheduled but is seen as run-time of the requesting application.

The runnables, accidentally named logicals in the model, are tasks which can be scheduled independently of each other. It is assumed that each runnable is periodic, thus they have a configurable priority, period and execution time. As mentioned earlier, runnables can request the latest received CAN message from the sink application. This request takes no time to complete and does not cause the sink application to be scheduled, the required execution time for such a request is assumed to be part of the runnable's execution time. It is assumed that all CAN frames are requested at the start of a logical's execution. Runnables can also request the transmission of a frame on a specific CAN bus. This is done by sending a CAN frame to the source application, the exact behaviour of the source application is described above. All transmissions are performed at the end of the runnable's execution. In reality read and send requests can occur throughout the runnable's execution, but for simplicity this model was chosen. Similarly, data dictionaries can be read or written by a runnable. All reads occur at the start of execution and take zero time to execute. All writes occur at the end of execution and also take zero time to execute.

\todo{beschrijf probleem van synchronisatie van data dictionaries in netwerk en dat we daarom de age bijhouden.}
Upon creation of a data dictionary sample a write-count is recorded inside the sample and an observer node records the generation time associated with that write count. Each time the data dictionary is read the observer node receives a signal containing the write-count of the read sample. Upon which the observer node calculates the age of the sample when it was read and stores that information for further analysis. To facilitate the transmission of data dictionaries between nodes Lightyear implemented two runnables responsible for receiving and transmitting CAN messages on each programmable end node. For messages received and transmitted by these runnables a one-to-one mapping between data dictionaries and CAN frame payload is known. The write-count can thus be reliably registered and forwarded alongside the CAN frame for further analysis when it is read by runnables in subsequent parametrizable end nodes. Unfortunately such a mapping is not available for CAN messages going to parametrizable end nodes. In case such a mapping is available the model will automatically transmit relevant data dictionary meta-data alongside the CAN frame.
\todo{wat zijn consequencies}

\paragraph{Parametrizable end nodes} As described in Section~\ref{subsec:network} the remaining nodes in the network are a mix of third party devices and fixed function devices created by Lightyear. The inner workings of these parametrizable end nodes is (mostly) unknown and only a specification of the CAN traffic is known. From the source code of programmable end node runnables interfacing with these nodes we deduce that most of the traffic is periodic. Unfortunately no structured data except the source code exists which describes which messages are periodic and which are aperiodic. As it seems that the majority of the traffic is periodic our model only implements periodic transmission of messages by the parametrizable end nodes. FiCo4OMNeT contains a module representing a CAN node which periodically transmits CAN messages. The module can also be configured to receive specific messages. The FiCo4OMNeT module is used to implement the parametrizable end node without further modifications.

\paragraph{CAN network} All CAN busses have been modelled using the CAN bus model provided by FiCo4OMNeT. This model takes care of details such as bit stuffing, error frame injection and handling and arbitration. Some changes were needed to make it compatible with the latest version of \omnet. These changes are publicly available\footnote{\url{https://github.com/StephanOostveen/FiCo4OMNeT/tree/feature/omnet6}} and have been sent to the package maintainers. 