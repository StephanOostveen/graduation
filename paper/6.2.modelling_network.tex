In this section we will describe how the Lightyear 0's embedded system as defined in Section~\ref{subsec:network} is modelled in OMNeT++. We also mention the assumptions made and the differences between the model and the real embedded system.

\paragraph{Programmable end nodes} OMNeT++ differentiates between simple modules and compound modules. Simple modules can be seen as the lowest level of the model, they implement the behaviour by means of C++ code which acts on the events received by that module. Compound modules do not have an implementation but serve as an abstraction layer grouping submodules and the connections between those submodules inside a named abstraction.

The programmable end nodes are implemented as a compound module. A generic compound module \textit{LyPhysicalNode} aggregates the internals of a programmable end node. Specialisations of the \textit{LyPhysicalNode} implement the final specific programmable end node, e.g. the \textit{VCUNode} compound module represents the Vehicle Control Unit by filling in details like the number of data dictionaries and their names, the number of runnables with the names and priorities and the read/write relationship between logicals and data dictionaries of the real world Vehicle Control Unit. The specialisations are generated from the source code such that they closely resemble the real world implementation. 

A \textit{LyPhysicalNode} consists of at least the following modules: the scheduler, one CAN source application, one CAN sink application, one up to four CAN devices. These modules represent the OpenECU RTOS as specified in section~\ref{subsec:programmablenode}. Their behaviour is modelled according to the documentation and the assumptions mentioned in section~\ref{subsec:programmablenode}. 

For simplicity we have only modelled the two CAN messaging tasks, the application background task from Table~\ref{tab:priorities} and the runnables implemented by Lightyear. The documentation did not specify the behaviour when two or more tasks of the same priority level are eligible for execution, we chose to take a random task from the list of the highest priority ready and paused tasks. In reality there could be some implicit ordering as the tasks are listed in some datastructure such as an array or list through which the scheduler iterates. 

The CAN device is a module imported from the FiCo4OMNeT model~\cite{meyer2019simulation}. It takes care of CAN message arbitration by implementing a priority based schedule. The device has an infinite amount of transmit buffers, which is not realistic. The source application module limits the number of messages buffered for transmission by the CAN device to a constant called \textit{hardwareBufferSize}. This constant is assumed to be two. If more than two CAN messages are scheduled for transmission by the runnables the CAN source task will store them in a software buffer following the priority queue mechanism. If a frame with a specific ID is retransmitted by a runnable before it was moved from the software buffer to the hardware buffer it will be overwritten as is defined in the documentation.

The CAN device implemented by FiCo4OMNeT has no receive buffers and will immediately transfer a received message to the sink application. This is not realistic behaviour, often a CAN peripheral will have several hardware receive buffers. As we do not know the inner workings of the receive task we assume received messages are immediately transfered to some software bu

\begin{figure}[htb]
    \centering
    \includegraphics[width=0.5\textwidth]{images/LyPhysicalNode_example.png}
    \caption{Example LyPhysicalNode compound module}
    \label{fig:lyphysicalnode}
\end{figure}

The CAN transmit task of the real-time operating system is implemented as a task which has priority number 4, which is the lowest priority task of the real-time operating system that we implement in our model.

\paragraph{Parametrizable end nodes}

\paragraph{CAN network}